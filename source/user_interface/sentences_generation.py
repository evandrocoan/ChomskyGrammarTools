#! /usr/bin/env python
# -*- coding: utf-8 -*-

import os
from PyQt5 import QtCore

from time import sleep
from threading import Lock

from debug_tools import getLogger

# level 4 - Abstract Syntax Tree Parsing
log = getLogger( 127-4, os.path.basename( os.path.dirname( os.path.abspath ( __file__ ) ) ) )


class UpdateGeneretedSentenceThread(QtCore.QThread):
    """
        Dynamically updates the user interface with new sentences generated by the program.
    """
    send_string_signal = QtCore.pyqtSignal( [str] )
    disable_stop_button_signal = QtCore.pyqtSignal()

    def __init__(self, firstGrammar, maximumSentenceSize, isToStop):
        """
            Qt- What is the difference between new QThread(this) and new QThread()?
            https://stackoverflow.com/questions/46293674/qt-what-is-the-difference-between-new-qthreadthis-and-new-qthread
        """
        QtCore.QThread.__init__(self)
        self.isToStop = isToStop

        self.firstGrammar = firstGrammar
        self.maximumSentenceSize = maximumSentenceSize

    def run(self):
        mutex = Lock()
        generate_sentences = []
        only_maximum_sentences = self.only_maximum_sentences

        class ProcessThread(QtCore.QThread):

            def __init__(self, parent, firstGrammar, maximumSentenceSize, isToStop):
                QtCore.QThread.__init__(self, parent)
                self.isToStop = isToStop

                self.firstGrammar = firstGrammar
                self.maximumSentenceSize = maximumSentenceSize

            def run(self):
                nonlocal mutex
                nonlocal generate_sentences
                self.firstGrammar.generate_sentences_of_size_n( self.maximumSentenceSize, generate_sentences, mutex, self.isToStop )

        is_first_time = True
        process_thread = ProcessThread( self.parent(), self.firstGrammar, self.maximumSentenceSize, self.isToStop )
        process_thread.start()
        count = 0

        while process_thread.isRunning() or is_first_time:
            is_first_time = False

            self.sleep( 1 )
            mutex.acquire()

            try:
                sentences_with_length_n = []

                if only_maximum_sentences:

                    for sentence in sorted( generate_sentences ):

                        if len( sentence ) == self.maximumSentenceSize:
                            count += 1
                            sentences_with_length_n.append( "%s. %s" % ( count, sentence ) )

                else:

                    for sentence in sorted( generate_sentences ):
                        count += 1
                        sentences_with_length_n.append( "%s. %s" % ( count, sentence ) )

                if len( sentences_with_length_n ):
                    self.send_string_signal.emit( "\n".join( sentences_with_length_n ) )

                else:
                    self.send_string_signal.emit( "No sentences available yet... "
                            "Current Size %s" % self.firstGrammar.last_non_terminal_length )

                generate_sentences.clear()

            finally:
                mutex.release()

        # If it was not stopped by the close event setting isToStop, then append the success message
        process_thread.wait()

        if not self.isToStop[0]:
            self.send_string_signal.emit( "\nGeneration completed successfully!" )
            self.disable_stop_button_signal.emit()

