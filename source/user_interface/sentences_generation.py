#! /usr/bin/env python
# -*- coding: utf-8 -*-

import os

from PyQt5 import QtCore
from PyQt5.QtCore import Qt

from time import sleep
from threading import Lock

from debug_tools import getLogger

# level 4 - Abstract Syntax Tree Parsing
log = getLogger( 127-4, os.path.basename( os.path.dirname( os.path.abspath ( __file__ ) ) ) )


class UpdateGeneretedSentenceThread(QtCore.QThread):
    """
        Dynamically updates the user interface with new sentences generated by the program.
    """
    send_string_signal = QtCore.pyqtSignal( [str] )
    disable_stop_button_signal = QtCore.pyqtSignal()

    def __init__(self, firstGrammar, maximumSentenceSize, isToStop):
        """
            Qt- What is the difference between new QThread(this) and new QThread()?
            https://stackoverflow.com/questions/46293674/qt-what-is-the-difference-between-new-qthreadthis-and-new-qthread
        """
        QtCore.QThread.__init__(self)
        self.isToStop = isToStop

        self.firstGrammar = firstGrammar
        self.maximumSentenceSize = maximumSentenceSize

    def run(self):
        mutex = Lock()
        generate_sentences = []
        only_maximum_sentences = self.only_maximum_sentences

        class ProcessThread(QtCore.QThread):

            def __init__(self, parent, firstGrammar, maximumSentenceSize, isToStop):
                QtCore.QThread.__init__(self, parent)
                self.isToStop = isToStop

                self.firstGrammar = firstGrammar
                self.maximumSentenceSize = maximumSentenceSize

            def run(self):
                nonlocal mutex
                nonlocal generate_sentences
                self.firstGrammar.generate_sentences_of_size_n( self.maximumSentenceSize, generate_sentences, mutex, self.isToStop )

        is_first_time = True
        process_thread = ProcessThread( self.parent(), self.firstGrammar, self.maximumSentenceSize, self.isToStop )
        process_thread.start()
        count = 0

        while process_thread.isRunning() or is_first_time:
            is_first_time = False

            self.sleep( 1 )
            mutex.acquire()

            try:
                sentences_with_length_n = []

                if only_maximum_sentences:

                    for sentence in sorted( generate_sentences ):

                        if len( sentence ) == self.maximumSentenceSize:
                            count += 1
                            sentences_with_length_n.append( "%s. %s" % ( count, sentence ) )

                else:

                    for sentence in sorted( generate_sentences ):
                        count += 1
                        sentences_with_length_n.append( "%s. %s" % ( count, sentence ) )

                if len( sentences_with_length_n ):
                    self.send_string_signal.emit( "\n".join( sentences_with_length_n ) )

                else:
                    self.send_string_signal.emit( "No sentences available yet... "
                            "Current Size %s" % self.firstGrammar.last_non_terminal_length )

                generate_sentences.clear()

            finally:
                mutex.release()

        # If it was not stopped by the close event setting isToStop, then append the success message
        process_thread.wait()

        if not self.isToStop[0]:
            self.send_string_signal.emit( "\nGeneration completed successfully!" )
            self.disable_stop_button_signal.emit()


class RunFunctionAsyncThread(QtCore.QThread):
    """
        Dynamically updates the user interface with new sentences generated by the program.
    """
    send_string_signal = QtCore.pyqtSignal( [str] )
    disable_stop_button_signal = QtCore.pyqtSignal()

    def __init__(self, function):
        """
            Qt- What is the difference between new QThread(this) and new QThread()?
            https://stackoverflow.com/questions/46293674/qt-what-is-the-difference-between-new-qthreadthis-and-new-qthread
        """
        QtCore.QThread.__init__(self)
        self.function = function

    def run(self):

        class ProcessThread(QtCore.QThread):

            def __init__(self, parent, function):
                QtCore.QThread.__init__(self, parent)
                self.function = function

            def run(self):
                self.function()

        process_thread = ProcessThread( self.parent(), self.function )
        process_thread.start()
        self.sleep( 1 )

        while process_thread.isRunning():
            self.send_string_signal.emit( "Computing... No results available yet... " )
            self.sleep( 1 )

        # If it was not stopped by the close event setting isToStop, then append the success message
        process_thread.wait()

        if not self.function.isToStop[0]:
            self.send_string_signal.emit( "\n%s\n\nComputation completed successfully!" % self.function.results )
            self.disable_stop_button_signal.emit()


def run_function_async(function, results_dialog):
    """
        Create the updating thread and connect
        it's received signal to append
        every received chunk of data/text will be appended to the text
    """
    qtUpdateThread = RunFunctionAsyncThread( function )
    qtUpdateThread.send_string_signal.connect( results_dialog.appendText )
    qtUpdateThread.disable_stop_button_signal.connect( results_dialog.disableStopButton )
    qtUpdateThread.start()

    # Autoscroll PyQT QTextWidget
    # https://stackoverflow.com/questions/7778726/autoscroll-pyqt-qtextwidget
    verticalScrollBar = results_dialog.textEditWidget.verticalScrollBar()
    horizontalScrollBar = results_dialog.textEditWidget.horizontalScrollBar()
    verticalScrollBar.setValue( horizontalScrollBar.maximum() )
    horizontalScrollBar.setValue( horizontalScrollBar.minimum() )

    # Block QMainWindow while child widget is alive, pyqt
    # https://stackoverflow.com/questions/22410663/block-qmainwindow-while-child-widget-is-alive-pyqt
    results_dialog.setWindowModality( Qt.ApplicationModal )
    results_dialog.show()

